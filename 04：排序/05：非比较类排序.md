### 非比较类排序

------

##### 1：计数排序：

​	统计每个待排元素相同值得个数,必须知道待排元素值的范围,需要额外的计数数组

- 例：有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位
- 时间复杂度：O(n + k)
  - 最优时：O(n + k)
  - 最差时：O(n + k)
- 稳定性：稳定

```java
const int k = 100;  	// 基数为100，排序[0,99]内的整数
int c[k];            	// 计数数组

void countingSort(int a[], int n) {
    int b[n];		
    for (int i = 0; i < k; i++)   // 初始化，置零
    {
        c[i] = 0;
    }
    for (int i = 0; i < n; i++)   // c[i]保存着等于i的元素的个数
    {
        c[a[i]]++;
    }

    for (int i = 1; i < k; i++)   // c[i]桶中保存着小于等于i的元素个数
    {
        c[i] = c[i] + c[i - 1];
    }

    for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)
    {
        b[--c[a[i]]] = a[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上
                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性
    }

    for (int i = 0; i < n; i++)   // 把临时空间b中的数据拷贝回a中
    {
        a[i] = b[i];
    }

}
```

##### 2：基数排序：在计数排序的基础上，将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零

- 从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，序列就变成一个有序序列
- 时间复杂度：O(n * dn)
  - 最优时：O(n * dn)
  - 最差时：O(n * dn)
- 稳定性：稳定

```java
const int dn = 3;                // 待排序的元素为三位数及以下
const int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数
int c[k];

int getDigit(int x, int d)          // 获得元素x的第d位数字，默认三位数
{
    int index[] = { 0, 1, 10, 100 };    
    return (x / index[d]) % 10;
}

void countingSort(int a[], int n, int d)
{
    int b[n];		

    for (int i = 0; i < k; i++)   // 初始化，置零
    {
        c[i] = 0;
    }

    for (int i = 0; i < n; i++)   // c[i]保存着等于i的元素的个数
    {
        c[getDigit(a[i], d)]++;
    }

    for (int i = 1; i < k; i++)   // c[i]保存着小于等于i的元素个数
    {
        c[i] = c[i] + c[i - 1];
    }

    for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)
    {
        b[--c[getDigit(a[i], d)]] = a[i];      // 把每个元素a[i]放到它在输出数组B中的正确位置上
                                           // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性
    }

    for (int i = 0; i < n; i++)   // 把临时空间b中的数据拷贝回a中
    {
        a[i] = b[i];
    }

}

void radixSort(int a[], int n)        // 最低位优先基数排序
{
    for (int d = 1; d <= dn; d++)     // 从低位到高位
        countingSort(a, n, d);        // 依据第d位数字对a进行计数排序
}
```






