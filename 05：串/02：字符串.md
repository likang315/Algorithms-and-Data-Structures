### 字符串

------

[TOC]

##### 01：反转字符串

- 原地修改输入数组、使用 O(1) 的额外空间


```java
// 前后交换，O(1)空间
public void reverseString(char[] s) {
    if (s.length <= 1) {  
        return;
    } else {
      // 奇偶无所谓
      for (int i = 0; i < s.length / 2; i++) {
            char x = s[s.length-(i + 1)];
            s[s.length-(i + 1)] = s[i];
            s[i] = x;
      }
    }
}
```

##### 02：整数反转

- 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转，可以用队列


```java
// % 10 就是取最后一位，每次除10 相当于少一位
public int reverse(int x) {
    int rev = 0;
    while (x != 0) {
        int pop = x % 10;
        if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) 
            return 0;
        if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8))
            return 0;
        rev = rev * 10 + pop;
      	x /= 10;
    }
    return rev;
}
```

##### 03：求一个字符串的所有子字符串（暴力）

```java
public void allchildString(String s) {
    for (int i = 0; i < s.length(); i++) {
        for(int j = i; j < s.length(); j++) {
          	// 不包含末尾下表
            System.out.print(s.substring(i, j + 1) + "  ");
        }
        System.out.println();
    }
}
```

##### 04：最长无重复子串

- **窗口函数**，两个指针，若需要返回区间需要增加两个指针，max交换时改变；

```java
// 滑动窗口，加区间标志指针
public int lengthOfLongestSubstring(String s) {
    HashSet<Character> set = new HashSet<Character>();
    // 一个控制头，一个控制尾（窗口）
    int sum = 0, i = 0, j = 0;
  	for (int j = 0; j < s.length(); ) {
         if (!set.contains(s.charAt(j))) {
              set.add(s.charAt(j++));
              // 和之前的区间长度最大的比较谁大
              sum = Math.max(sum, j-i);    
         } else {
              // 直到重复的除去为止
              set.remove(s.charAt(i++));  
         }
    }
    return sum;
}
```

##### 05：最长回文子串

1. 回文串：前后对称串。**中心扩展算法**：以每个字母为回文中心，考虑回文长度为奇数和偶数的情况
2. 时间复杂度：O(n^2)
3. 空间复杂度：O(1)

```java
class Solution {
  public String longestPalindrome(String s) {
    if (s == null && s.length() == 0)
      return "";
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandCenter(s, i, i); // aba
        int len2 = expandCenter(s, i , i + 1); // abba
        int len = Math.max(len1, len2);
      	// 记录回文子串
        if (len > end - start) {
          start = i - (len - 1) / 2;
          end = i + len / 2;
        }
    }
    // 截取：[ ）
    return s.substring(start, end + 1);
  }
  
  public int expandCenter(String s,int left,int right) {
      // 控制边界、相等条件
      while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
          left--;
          right++;
      }
      // 两边扩充一对，右边没有除去
      return right-left-1;
  }
}
```

##### 6：最长公共子串：

- 子串：字符串中连续的子串

![]()

```java
// DP算法：借助二维数组
public int getCommonSubStrLength(String s1, String s2) {
  	int row = s1.length();
    int col = s2.length();
  	char[] c1 = s1.toCharArray();
    char[] c2 = s2.toCharArray();
  	// 从第一位开始，因为要-1，不能越界
    int[][] dp = new int[row + 1][col+ 1];
  	int max = -1;
  	for (int i = 1; i <= row; i++) {
    		for (int j = 1; j <= col; j++) {
    				if (c1[i-1] == c2[j-1]) {
        				dp[i][j] = dp[i-1][j-1] + 1;
        				if (dp[i][j] > max) {
                  // 可以加两个指针返回最长子串
        					max = dp[i][j];
       		  		}
            }
    		}
  	}
  	return max;
}
```

##### 7：最长公共子序列

- 字符子序列：字符串中不一定连续但先后顺序必须一致

![](https://github.com/likang315/Algorithms-and-Data-Structures/raw/master/5%EF%BC%9A%E4%B8%B2/String/LCS.png?raw=true)

```java
public int LCS(String s1, String s2) {
  	int row = s1.length();
    int col = s2.length();
    int[][] dp = new int[row + 1][col+ 1];
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= col; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                //上面和左面的谁大赋谁
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    // 返回dp的最后一个值 
    return dp[row][col];
}
```

##### 8：将String 1 变为 String 2 的 最小操作数

```java
public int minExchange(String s1, String s2) {
    int row = s1.length();
    int col = s2.length();
    int[][] dp = new int[row+1][col+1];
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= col; j++) {
            if (word1.charAt(i - 1) == word2.charAt( j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    // s1 + s2 总长度 - s1和s2共同的最大公共子序列
  	// 删除多余的
    return row + col - 2 * dp[row][col];
}
```

##### 9：





