### 二叉查找树的前(先)，中，后序遍历

##### 1：递归：先放左子女，再放右子女

```c
void preOrder(BTNode * root)                 //前序遍历
{
	if (root)
	{
		printf("%5d", root->data);
		preOrder(root->left);
		preOrder(root->right);
	}
}

void inOrder(BTNode * root)           //中序遍历
{
	if (root)
	{
		inOrder(root->left);
		printf("%5d", root->data);
		inOrder(root->right);
	}
}

void postOrder(BTNode * root)               //后序遍历
{
	if (root)
	{
		postOrder(root->left);
		postOrder(root->right);
		printf("%5d", root->data);
	}
}

int main()
{
	int a[N] = { 1,2,3,4,5,6,7,8,9,0 };
	BTNode *root;
	root=creatLink(a, N);
	if (root)
		printf("CreatLink successful!\n");
	else
		printf("CreatLink Failure !\n");
     preOrder(root);
     printf("\n");
     inOrder(root);
     printf("\n");
     postOrder(root);
     return 0;
}
```

##### 2：非递归

```c
//前序遍历:先放右，再放左
include<stdio.h>
include<stdlib.h>
define N 100

typedef struct node
{
	int data;
	struct node *left;
	struct node *right;
}BTNode;

void preOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s[++top] = root;
	while (top ！= -1)     
	{
		p = s[top--];
		printf("%5d", p->data);
		if (p->right)
			s[++top] = p->right;
		if (p->left)
			s[++top] = p->left;
	}
	free(s);
}



//中序遍历：先一直往左，把所有的左子女放入，直到为空时，出栈输出根，在赋器右结点
void inOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	p = root;
	while (top != -1 || p)      //中序遍历,利用栈，用 || ，出根时栈空
	{
		while(p)
		{
			s[++top]=p;
			p=p->left;
		}
		if(top != -1)		//出栈时需要判断栈不为空
		{
			p = s[top--];
			printf("%d ",p->data);
			p=p->right;	
		}
	}
	free(s);
}


//后序遍历:借用两个栈，第一个进行逆后序遍历，另一个存储第一个栈的栈顶值，然后直到第一个站取空，输出第二个栈即是后序遍历
逆后序：根右左 ，后序遍历：左右根
逆后序,入栈输出得后序遍历	
void postOrder(BTNode * root )
{
	BTNode **s1,**s2;
	BTNode *p;
	int top1=-1,top2=-1;
	//创建栈
	s1 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s2 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s1[++top1] = root;
	while(top1 != -1)
	{	
		p = s1[top1--];
		s2[++top2] = p;
		if(p->left)
			s1[++top1]=p->left;
		if(p->right)	
			s1[++top1]=p->right;
	}
    while(top2 != -1)
    {
        p = s2[top2--];
        printf("%5d",p->data);	
    }
    free(s1);
    free(s2);
}
```


