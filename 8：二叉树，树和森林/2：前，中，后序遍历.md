### 二叉查找树 的 前(先)，中，后序遍历：二叉树的深度优先遍历（DFS）

##### 1：递归：先放左子女，再放右子女

```java
void preOrder(TreeNode root)                 //前序遍历
{
	if (root!=null)
	{
		System.out.println(root.data);
		preOrder(root.left);
		preOrder(root.right);
	}
}

void inOrder(TreeNode root)           //中序遍历
{
	if (root!=null)
	{
		inOrder(root.left);
		System.out.println(root.data);
		inOrder(root.right);
	}
}

void postOrder(TreeNode root)               //后序遍历
{
	if (root!=null)
	{
		postOrder(root.left);
		postOrder(root.right);
		System.out.println(root.data);
	}
}
```

##### 2：非递归，借助栈

###### 先把 root入栈，其他在循环中入

```java
//前序遍历
void preOrder(TreeNode root )
{
	TreeNode p;
	//利用栈
    Stack<TreeNode> stack = new Stack<TreeNode>();
   	stack.push(root);
	while (!stack.isEmpty())
	{
		p = stack.pop();
		System.out.println(p.val);
         //先入右子女
		if (p.right!=null)	
			stack.push(p.right);
		if (p.left!=null)
			stack.push(p.left);
	}
 }

//中序遍历：先一直往左，把所有的左子女放入，直到为空时，出栈输出根，在赋器右结点
void inOrder(TreeNode root )
{
	TreeNode p;
	//创建栈
    Stack<TreeNode> stack = new Stack<TreeNode>();
   	stack.push(root);
	while (!stack.isEmpty() || p! = null)      //中序遍历,利用栈，用 || ，出根时栈空
	{
         p = root;
         //把所有的左子女，入栈
		while( p!=null )
		{
			stack.push(p);
			p=p.left;
		}
		if(！stack.isEmpty())		//出栈时，需要判断栈不为空
		{
			p = stack.pop();
			System.out.println(p.val);
			p=p.right；
		}
	}
}

//后序遍历:借用两个栈，第一个进行逆后序遍历，另一个存储第一个栈的栈顶值，然后直到第一个站取空，输出第二个栈即是后序遍历
逆后序：根右左 ，后序遍历：左右根
逆后序,入栈输出得后序遍历
void postOrder(TreeNode root )
{
	TreeNode p;
	//创建栈
	Stack<TreeNode> stack1 = new Stack<TreeNode>();
	Stack<TreeNode> stack2 = new Stack<TreeNode>();
	stack1.push(root);
	while(!stack1.isEmpty())
	{	
		p = stack1.pop();
		stack2.push(p);
		if(p.left!=null)
			stack1.push（p.left);
		if(p.right!=null)	
			stack1.push(p.right)；
	}
    while(!stack2.isEmpty())
    {
        p = stack2.pop();
        System.out.println(p.val);	
    }
}
```





```c
//前序遍历:先放右，再放左
include<stdio.h>
include<stdlib.h>
define N 100

typedef struct node
{
	int data;
	struct node *left;
	struct node *right;
}BTNode;

void preOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s[++top] = root;
	while (top ！= -1)     
	{
		p = s[top--];
		printf("%5d", p->data);
		if (p->right)
			s[++top] = p->right;
		if (p->left)
			s[++top] = p->left;
	}
	free(s);
}



//中序遍历：先一直往左，把所有的左子女放入，直到为空时，出栈输出根，在赋器右结点
void inOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	p = root;
	while (top != -1 || p)      //中序遍历,利用栈，用 || ，出根时栈空
	{
		while(p)
		{
			s[++top]=p;
			p=p->left;
		}
		if(top != -1)		//出栈时需要判断栈不为空
		{
			p = s[top--];
			printf("%d ",p->data);
			p=p->right;	
		}
	}
	free(s);
}


//后序遍历:借用两个栈，第一个进行逆后序遍历，另一个存储第一个栈的栈顶值，然后直到第一个站取空，输出第二个栈即是后序遍历
逆后序：根右左 ，后序遍历：左右根
逆后序,入栈输出得后序遍历	
void postOrder(BTNode * root )
{
	BTNode **s1,**s2;
	BTNode *p;
	int top1=-1,top2=-1;
	//创建栈
	s1 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s2 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s1[++top1] = root;
	while(top1 != -1)
	{	
		p = s1[top1--];
		s2[++top2] = p;
		if(p->left)
			s1[++top1]=p->left;
		if(p->right)	
			s1[++top1]=p->right;
	}
    while(top2 != -1)
    {
        p = s2[top2--];
        printf("%5d",p->data);	
    }
    free(s1);
    free(s2);
}
```


