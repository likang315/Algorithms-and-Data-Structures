## B 树（B- 树）和 B+树

## b树（balance tree）和b+树可以认为是 m 叉的多路平衡查找树

对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小

##### M阶的 b树 特征：

1. 定义任意非叶子结点最多只有M个儿子（子节点），且M>2
2. 根结点的儿子数为[2, M]
3. 除根结点以外的非叶子结点的儿子数区间为[M/2, M]，向上取整
4. 非叶子结点的关键字个数 = 儿子数-1
5. 所有叶子结点位于同一层
6. k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系

##### b树的一些特性，注意与后面的b+树区分：

1. 关键字集合分布在整颗树中；

2. 任何一个关键字出现且只出现在一个结点中；

3. 搜索有可能在非叶子结点结束；

4. 其搜索性能等价于在关键字全集内做一次二分查找；

   ### 三阶B树

![B树.png](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/B%E6%A0%91.png?raw=true)

### B树的插入和删除

首先自顶向下查询找到4应该在的位置，即3、5之间，但是3阶b树的节点最多只能有2个元素，所以把3、4、5里面的中间元素4上移（中间元素上移是插入操作的关键），上一层节点加入4之后也超载了，继续中间元素上移的操作，现在根节点变成了4、9，还要满足查找树的性质，所以对元素进行调整以满足大小关系，始终维持多路平衡也是b树的优势，最后

##### 插入：中间元素上移的操作

##### 删除：删除后满足B树条件

## B+树

### b+树，是b树的一种变体，查询性能更好，m阶的b+树的特征：

1. 有n棵子树的非叶子结点中**含有n个关键字 （b树是n-1个）**，这些**关键字不保存数据，只用来索引**，所有数据都保存在叶子节点（b树是每个关键字都保存数据）
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且**叶子结点本身依关键字的大小自小而大顺序链接**
3. 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字
4. 通常在 b+树 上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点
5. 同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素**

![B树.png](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/B%E6%A0%91.png?raw=true)



### B树，B+树 区别优势

######  1) B+树的磁盘读写代价更低，IO次数更少

B树 每个节点中不仅存储索引信息，还存储了存其对应的数据，如果数据很大，那么当树的体量很大时，每次读到内存中的树的信息就会不太够，而B+的只有索引信息

######  2）B+树的数据信息遍历更加方便，范围查询更加方便

B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且 在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树

######  3) B+树的查询效率更加稳定

任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当





