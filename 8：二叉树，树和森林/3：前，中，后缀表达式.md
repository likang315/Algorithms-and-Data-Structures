### 1：前，中，后缀表达式

?	将自然表达式按照优先级顺序，构造出与表达式相对应的二叉树，然后对二叉树进行前/中/后缀遍历,即得到前/中/后缀表达式即不需要括号就可以表达表达式

[![前中后缀表达式.png](https://github.com/likang315/Algorithms-and-Data-Structures/raw/master/8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.png?raw=true)](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/8：二叉树，树和森林/前中后缀表达式.png?raw=true)

```
自然表达式（中缀表达式）： a×(b+c)-d
前缀表达式： -*a+bcd ，对二叉树进行前序遍历
中缀表达式： a*b+c-d ，对二叉树进行中序遍历
后缀表达式： abc+*d- ，对二叉树进行后序遍历
```

### 前缀表达式(波兰式)：

?	1:从左至右扫描表达式，如果一个操作符后面跟着两个操作数时，则计算，然后将结果作为操作数替换(这个操作符和两个操作数)，重复此步骤，直至所有操作符处理完毕 ?	2:用一个**栈S2来实现计算，扫描从右往左进行**，如果扫描到操作数，则压进S2，如果扫描到操作符，则从S2弹出两个操作数进行相应的操作，并将结果压进S2(S2的个数出2个进1个),当扫描结束后，S2的栈顶就是表达式结果

### 后缀表达式(逆波兰式)：

?	用一个**栈S2来实现计算，扫描从左往右进行**，如果扫描到操作数，则压进S2，如果扫描到操作符，则从S2弹出两个操作,进行相应的操作，并将结果压进S2(S2的个数出2个进1个),当扫描结束后，S2的栈顶就是表达式结果

中缀表达式和波兰式,逆波兰式之间的转换 当我们在计算中缀表达式的时候，我们只需要把所有优先级用括号标注起来，然后再根据波兰式和逆波兰式，前者把操作符提前，后者提后，再把括号去掉

```
中缀表达式：3*（2-（5+1））
波兰表达式                                    逆波兰表达式
（3*（2-（5+1）））                          （3*（2-（5+1）））
 *（3-（2+（5 1）））                        （3（2（5 1）+）-）*
 * 3 - 2 + 5 1   			      		    3 2 5 1 + - *  
```