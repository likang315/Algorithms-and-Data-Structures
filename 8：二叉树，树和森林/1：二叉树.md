###### 树：根结点（root）,叶子结点(leaf),双亲结点，子女结点，兄弟节点概念

###### 度：

###### 1：结点的度：一个结点的子女的个数

###### 2：树的度：树中度值最大的结点的度

###### 3：树的高度：树中结点的最大高度

层次：根结点的层树次为1，其余结点的层次等于该结点的双亲结点的层次加1									无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置
有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置
**森林**：0个或多个不相交的树组成，对森林加上一个根，森林即成为树；删去根，树即成为森林

## 二叉树：度值最大为2 的树，二叉链表（双向链表）

![二叉树.jpg](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg?raw=true)

###### 性质：

1：任何一个给空二叉树的**叶子结点总比双分支结点多 1**														2：二叉树第i层上的结点数目最多为 **2{i-1}， (i≥1)**																3：深度为k的二叉树至多有**2{k}-1**个结点(k≥1)，满二叉树													4：包含n个结点的二叉树的高度至少为**log2 (n+1)**																5：对二叉树的结点进行编号（缺失的结点也要编号）																结论：对于编号为 i 的结点，若有左子女，那么左子女的编号是**2i**，若有右子女，那么一定为**2i+1,**其双亲结点**[i/2]**,即向上取整

**满二叉树**：二叉树的每一层结点个数都达到最大值的二叉树														**完全二叉树**：前 **i** 层是满的，最后一层连续缺失右边的结点														**二叉查找树**：(Binary Search Tree)，又被称为二叉搜索树，左比它小，右比它大									**理想平衡树**：前i-1层是满的，最后一层任意摆放															**歪斜树**：明显朝一遍倾斜的数

```c
typedef struct node
{
	int data;
	struct node * left;
	struct node * right;
}BTNode;
```

```java
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
```



### 1：构造二叉查找树

```java
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

//需要三个指针，一个前驱，一个当前，一个新创建的
public TreeNode  creatLink(int[] a)
{
        TreeNode c,q;
        //创建根节点
        TreeNode root=new TreeNode(a[0]);
        root.left=root.right=null;
        for(int i=1;i<a.length;i++)
        {
            //新创建节点
            TreeNode p = new TreeNode(a[i]);
            p.left = p.right = null;
            //当前结点
            c=root;
            while( c != null)
            {
                //前一节点
                q = c;
                if(p.val < c.val)
                    c = c.left;
                else
                    c = c.right;
            }
            if(p.val < q.val)
                q.left = p;
            else
                q.right=p;
        }
        return root;
}
```



```c
include<stdio.h>
include<stdlib.h>
define N 10

typedef struct node
{
	int data;
	struct node * left;
	struct node * right;
}BTNode;

BTNode * creatLink(int a[], int n)                 //创建二叉查找树,分头和中间尾
{
	BTNode *root, *c, *q, *p;
	root = (BTNode *)malloc(sizeof(BTNode));    //创建根结点
	root->data = a[0];
	root->left = root->right = NULL；                
	for (int i = 1; i < n; i++)
	{
		p = (BTNode *)malloc(sizeof(BTNode));
		p->data = a[i];
		p->left = p->right = NULL;              //创建其余结点
		c = root;
		while (c)                                //从根开始比较大小找到叶子节点，并且有指针q
		{
			q = c;
			if (p->data < c->data)
				c = c->left;
			else
				c = c->right;
		}
        if (p->data < q->data)         //比较大小挂结点
			q->left = p;
        else
			q->right = p;
     }
	return root;
}

int main()
{
	int a[N] = { 1,2,3,4,5,6,7,8,9,0 };
	BTNode *root;
	root=creatLink(a, N);
	if (root)
		printf("CreatLink successful!");
	else
		printf("CreatLink Failure !");
	return 0;
}
```



### 2：二叉树按层遍历（广度优先搜索算法（Breadth First Search））

```java
//借助队列
public void levelOrder（TreeNode root）
{
     TreeNode p;
     Queue<TreeNode> queue = new LinkList<TreeNode>();
     queue.offer(root);
     while(!queue.isEmpty())
     {
         p = queue.poll();
         System.out.println(p.val);
         if(p.left != null)
         	queue.offer(p.left);
         else
         	queue.offer(p.right);
     }
}
```



### 3：镜像二叉树（翻转二叉树）

```java
//从下往上，先把走到叶子结点，在交换左右子女，在回溯
public void mirrorTreeNode (TreeNode root)
{
    if(root == null)
        return null;
    //对左右孩子镜像处理
    TreeNode left = mirrorTreeNode(root.left);
    TreeNode right= mirrorTreeNode(root.right);
    
    //对当前节点进行镜像处理
    root.left=right;
    root.right=left;
    return root;    
}

//借助栈，从上往下，按层把当前节点的左右子女交换，然后左右入栈
public void mirrorTreeNode (TreeNode root)
{
    if(root==null)
        return ;
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);
    while(!stack.isEmpty())
    {
        //当栈不为 null 时出栈，交换当前结点的左右子树
        TreeNode p = stack.pop();
        //交换左右子女
        TreeNode left,right;
        left = p.left;
        right = p.right;
        p.right = left;
        p.left = right;
        
        if(p.left!=null)
            stack.push(p.left);
        
        if(p.right!=null)
            stack.push(p.right);
    }
}
```



### 4：二叉树的深度

```java
//递归，一直到底层，才开始回溯，时间复杂度 O(n)
public int maxDepth(TreeNode root)
{
    if (root == null) 
        return 0;
    else 
    {
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}


//非递归(迭代), DFS 策略访问每个结点，同时在每次访问时更新最大深度
public int maxDepth(TreeNode root)
{
    Queue<HashMap<TreeNode, Integer>> queue = new LinkedList<HashMap<TreeNode,Integer>> ();
    if (root != null) 
        queue.offer(new HashMap(root, 1));

    int depth = 0;//定义深度
    while (!queue.isEmpty())
    {
        HashMap<TreeNode, Integer> current = queue.poll();
        root = current.getKey();
        int current_depth = current.getValue();
        //不用判断左右子女为空，直接入队，出队时，为空直接跳过
        if (root != null) 
        {
            depth = Math.max(depth, current_depth);
            queue.offer(new HashMap(root.left, current_depth + 1));
            queue.offer(new HashMap(root.right, current_depth + 1));
        }
    }
    return depth;
}
```



### 5：二叉树转为链表

```java
//先序遍历的链表结果，也可以先序遍历存储结点，挂链
public void change(TreeNode root)
{
    if(root == null) 
        return;
    change(root.left); 
    change(root.right);
    //把右子女赋给其左子女，再把左子女赋给右结点，左子女置空
    if(root.left != null)
    {
        TreeNode node = root.left;
        //最后一个右子女
        while(node.right != null)
            node = node.right;
        
        node.right = root.right;
        root.right = root.left;
        root.left = null;
    }
}
```



### 6：二叉树的最近公共祖先

```java
//一个节点也可以是它自己的祖先
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)
{
        if (root == null) {
            return root;
        }
    	//两个结点
        if (root == p || root == q) {
            return root;
        }
    
        TreeNode left =  lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null)
        {
            return root;
        } else if (left != null)
        {
            return left;
        } else if (right != null) 
        {
            return right;
        }
        return null;
}
```





