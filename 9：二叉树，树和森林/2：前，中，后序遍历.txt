
二叉查找树的前(先)，中，后序遍历


1：递归

void preOrder(BTNode * root)                 //前序遍历
{
	if (root)
	{
		printf("%5d", root->data);
		FOrder(root->left);
		FOrder(root->right);
	}
}


void inOrder(BTNode * root)           //中序遍历
{
	if (root)
	{
		MidOrder(root->left);
		printf("%5d", root->data);
		MidOrder(root->right);
	}
}

void postOrder(BTNode * root)               //后序遍历
{
	if (root)
	{
		LOrder(root->left);
		LOrder(root->right);
		printf("%5d", root->data);
	}
}


int main()
{
	int a[N] = { 1,2,3,4,5,6,7,8,9,0 };
	BTNode *root;
	root=creatLink(a, N);
	if (root)
		printf("CreatLink successful!\n");
	else
		printf("CreatLink Failure !\n");

	preOrder(root);
	printf("\n");
	inOrder(root);
	printf("\n");
	postOrder(root);
	return 0;
}




2：非递归


前序遍历

#include<stdio.h>
#include<stdlib.h>
#define N 100
typedef struct node
{
	int data;
	struct node *left;
	struct node *right;
}BTNode;


void preOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s[++top] = root;
	while (top ！= -1)      //前序遍历，栈
	{
		p = s[top--];
		printf("%5d", p->data);
		if (p->right)
			s[++top] = p->right;
		if (p->left)
			s[++top] = p->left;
	}
	free(s);
}



中序遍历

void inOrder(BTNode * root )
{
	BTNode **s;
	BTNode *p;
	int top=-1;
	//创建栈
	s = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	p = root;
	while (top != -1 || p)      //中序遍历,利用栈，用 || ，出根时栈空
	{
		while(p)
		{
			s[++top]=p;
			p=p->left;
		}
		if(top != -1)		//出栈时需要判断栈不为空
		{
			p = s[top--];
			printf("%d ",p->data);
			p=p->right;	
		}
	}
	free(s);
}




后序遍历
	前序：根左右  逆后序：根右左
  
  逆后序,入栈输出得后序遍历
	
void postOrder(BTNode * root )
{
	BTNode **s1,**s2;
	BTNode *p;
	int top1=-1,top2=-1;
	//创建栈
	s1 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s2 = (BTNode **)malloc((N + 1) * sizeof(BTNode *));
	s1[++top1] = root;
	while(top != -1)
	{	
		p = s1[top1--];
		s2[++top2] = p;
		if(p->left)
			s1[++top1]=p->left;

		if(p->right)	
			s1[++top1]=p->right;
	}
	while(top2 != -1)
	{
		p = s2[top2--];
		printf("%5d",p->data);	
	}
	
	free(s1);
	free(s2);
}




