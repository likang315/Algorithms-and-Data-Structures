
贪心算法：选择局部最优,但不一定是最优解，寻找局部最优的迭代过程

#include<stdio.h>
#include<stdlib.h>
#define V 10

//物品信息
typedef struct {
	int gnu;
	int gv;
}ElemG;
//物品结点
typedef struct node1 {
	int gnu;
	struct node1 *link;
}GoodsLink;
//箱子结点
typedef struct node2 {
	int remainder;
	GoodsLink *hg;
	struct node2 *next;
}BoxLink;

//1：初始化物品信息
ElemG * goods(int n) {
	ElemG *g;
	g = (ElemG *)malloc(n * sizeof(ElemG));
	for (int i = 0; i < n; i++) {
		int w;
		g[i].gnu = i + 1;
		printf("Please input the %d volume of goods:", i+1);
		scanf("%d", &w);
		g[i].gv = w;
	}
	return g;
}

//2：物品体积降序排列
void sortD(ElemG *g,int n) {
	ElemG t;
	for (int i = 0; i < n - 1; i++) {
		for (int j = i + 1; j < n; j++) {
			if (g[i].gv < g[j].gv) {
				t =g[i];
				g[i] = g[j];
				g[j] = t;
			}
		}
	}
}

//3：装箱
BoxLink * Packing(ElemG *g, int n) {
	BoxLink *hbox=NULL, *tail, *p;
	GoodsLink *q, *newg;
	for (int i = 0; i < n; i++) {
		for (p = hbox; p&&p->remainder < g[i].gv; p = p->next);
		if (!p) {
			p = (BoxLink *)malloc(sizeof(BoxLink));
			p->remainder = V;
			p->hg=NULL;
			p->next = NULL;
			if (!hbox) 
				hbox = tail = p;
			else
				tail = tail->next = p;
		}
		p->remainder -= g[i].gv;
		newg = (GoodsLink *)malloc(sizeof(GoodsLink));
		newg->gnu = g[i].gnu;
		newg->link = NULL;
		for (q = p->hg; q&&q->link; q = q->link);
		if (!q)
			p->hg = newg;
		else
			q->link = newg;
	}
	free(g);
	return hbox;
}

//4：输出
void printBox(BoxLink *hbox) {
	int i = 0;
	BoxLink *p;
	GoodsLink *q;
	for (p = hbox; p; p = p->next) {
		printf("第%d个箱子：",++i);
		for (q = p->hg; q; q = q->link) 
			printf("%5d  ", q->gnu);
			printf("\n");
		
	}
	free(hbox);
}


int main(void) {
	ElemG *g;
	BoxLink *hbox;
	int n;//物品个数
	printf("Please input n:");
	scanf("%d", &n);

	//初始化物品信息
	g = goods(n);
	//降序
	sortD(g, n);
	//装箱
	hbox=Packing(g, n);
	//输出
	printBox(hbox);

	return 0;
}











