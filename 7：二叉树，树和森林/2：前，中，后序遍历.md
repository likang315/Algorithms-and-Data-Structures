### 前(先)、中、后序遍历：二叉树的深度优先遍历（DFS）

------

##### 1：递归：先访左子女，再访右子女

```java
// 前序遍历
public void preOrder(TreeNode root) {
	if (root != null) {
		System.out.println(root.data);
		preOrder(root.left);
		preOrder(root.right);
	}
}
// 中序遍历
public void inOrder(TreeNode root) {
	if (root != null) {
		inOrder(root.left);
		System.out.println(root.data);
		inOrder(root.right);
	}
}
// 后序遍历
public void postOrder(TreeNode root) {
	if (root != null) {
		postOrder(root.left);
		postOrder(root.right);
		System.out.println(root.data);
	}
}
```

##### 2：非递归，借助栈

​	先把 root 入栈，其他在循环中入栈

```java
// 前序遍历:借助一个栈，先入右子女，再入左子女
public void preOrder(TreeNode root) {
    TreeNode p;
    // 借助栈
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
      p = stack.pop();
      System.out.println(p.val);
      // 先入右子女
      if (p.right != null)	
        stack.push(p.right);
      if (p.left != null)
        stack.push(p.left);
    }
}
// 中序遍历：先一直往左，把所有的左子女放入，直到为空时，出栈输出根，再赋其右结点
public void inOrder(TreeNode root ) {
    TreeNode p = root;
    Stack<TreeNode> stack = new Stack<>();
    // 利用栈，用 || ，出根时栈空
    while (!stack.isEmpty() || p != null) {
    		// 把所有的左子女，入栈
        while (p != null) {
          stack.push(p);
          p = p.left;
        }
      	// 出栈时，需要判断栈不为空
        if (!stack.isEmpty()) {
          p = stack.pop();
          System.out.println(p.val);
          p = p.right；
        }
    }
}
// 后序遍历:借用两个栈
// 第一个栈进行逆后序遍历，另一个存储第一个栈的栈顶值，然后直到第一个栈取空，输出第二个栈即是后序遍历
// 逆后序：根右左 ，后序遍历：左右根
// 逆后序,入栈输出得后序遍历
public void postOrder(TreeNode root) {
    TreeNode p;
    // 借助两个栈
    Stack<TreeNode> stack1 = new Stack<>();
    Stack<TreeNode> stack2 = new Stack<>();
    stack1.push(root);
    while (!stack1.isEmpty()) {
      p = stack1.pop();
      stack2.push(p);
      if (p.left != null)
        stack1.push（p.left);
      if (p.right != null)	
        stack1.push(p.right)；
    }
  	// 栈的遍历
    while (!stack2.isEmpty()) {
        p = stack2.pop();
        System.out.println(p.val);	
    }
}
```


