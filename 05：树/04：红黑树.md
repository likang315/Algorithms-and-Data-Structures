### 红黑树

------

[TOC]

##### 01：平衡二叉树（Self-balancing binary search tree）：AVL树

- 它必须是一个二叉查找树
- 它是一棵空树或它的左右两个子树的**高度差的绝对值不超过1**，并且左右两个子树都是一棵平衡二叉树
- 最小二叉平衡树的节点总数的公式：F(n) = F(n-1)+F(n-2)+1
  - 1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量

###### 构造平衡二叉树

- 首先要遵循二叉查找树，左比它小、右比它大的规律，再通过左旋和右旋来调整构造平衡二叉树
- ![](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/AVL.png)

###### 平衡二叉树性能

- 二叉平衡树要求严格按照**平衡策略**以牺牲，建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度，它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找、插入、删除；

##### 02：二叉查找树（Binary Search Tree）:

- 其期望高度（即为一棵平衡树时）为logn，其各操作的时间复杂（O(logn)）同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)

###### 时间复杂度：对数阶

```java
int count = 1; // 2^0 = 1
while (count < n) {
  count = count * 2 ;
}
// 每次count * 2，即是有多少个2相乘后大于n，退出循环
// 数学公式：2^x = n --> x = log2n (log以2为低n的对数)
// 因此这个循环的时间复杂度为O(logn)
```

##### 03：2-3-4 树

- 2-3-4树是**阶数为4的B树**，而红黑树的本质其实也是对概念模型：**2-3-4树的一种实现**；
- ![](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/2-3-4.jpeg)

##### 04：红黑树：

- 是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会**超过二者中较低那个的一倍**，有序，时间复杂度： O(logn)；
- ![](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/red-black.png)

###### 红黑树【五条定义】

1. 每个节点要么是红色，要么是黑色；
2. **根节点必须是黑色**；
3. **所有叶子节点都是黑色**；
4. **红色节点不能连续**（即红色节点的孩子和父亲都不能是红色）；
5. 任意节点到叶子节点经过的**黑色节点数目相同**；

###### 调整

- 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件调整可以分为两类：
  1. 颜色调整，即改变某个节点的颜色；
  2. 结构调整，即改变检索树的结构关系；
     - 左旋（Rotate Left），右旋（Rotate Right）

###### 左旋（右倾）

- 把x进行左旋，把y 的左子女赋给 x 的右子女；
- ![](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/red-black-left.png)

###### 右旋（左倾）

- 把Y右旋，把X的右子女赋给Y的左子女；
- ![](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/red-black-right.png)

##### 05：红黑树插入操作

1. 将红黑树当作一颗二叉查找树，将节点插入
2. 将插入的节点着色为"红色"
3. 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树
   - 情况说明：被插入的节点是根节点
     - 处理方法：直接把此节点涂为黑色
   - 情况说明：被插入的节点的父节点是黑色
     - 处理方法：什么也不需要做。节点被插入后，仍然是红黑树
   - 情况说明：被插入的节点的父节点是红色
     -  处理方法：该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)
     - **核心：将红色的节点移到根节点；然后，将根节点设为黑色**

##### 06：红黑树删除操作

1. 将红黑树当作一颗二叉查找树，将节点删除；
   1. 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK
   2. 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置
   3. 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”，然后删除“它的后继节点”
2. 通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树

##### 07：红黑树的性能

- 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证**每次插入最多只需要三次旋转就能达到平衡**，实现起来也更为简单；
- 红黑树通过**左旋右旋**来调整树的高度，从而提高查询效率，它能**保证最坏情况下仍然具有对数的时间复杂度**；
- **降低树的高度，因为树的查找性能取决于树的高度。所以树的高度越低搜索的效率越高！**

