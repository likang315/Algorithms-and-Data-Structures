### B 树（B-树）、B+树、B* 树

------

[TOC]

##### 01：B 树（balance tree）、B+树

- 对于树来说，**IO次数就是树的高度**，而“矮胖”就是b树的特征之一，它的**每个节点最多包含M个孩子，M称为B树的阶**，m的大小取决于磁盘页的大小，统称为**M叉的多路平衡查找树**；


###### M阶的B树特性：

1. 定义任意非叶子结点**最多只有M个结点（子节点）**，且M>2；
2. 根结点的儿子数为[2, M]，根结点之外的**非叶子结点的儿子数区间为[M/2, M]**，向上取整；
4. 非叶子结点的关键字个数 = 儿子数-1；
5. **所有叶子结点位于同一层**；
6. **k个关键字把节点拆成k+1段，分别指向k+1个儿子，满足查找树的大小关系**；

###### B 树的特性

1. 关键字集合分布在整颗树中；
2. 任何一个关键字出现且只出现在一个结点中；
3. 搜索有可能在非叶子结点结束；
4. 其搜索性能等价于在关键字全集内做一次二分查找；

###### 三阶B树

![B-tree](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/B-tree.png)

###### B树的插入和删除

- 首先自顶向下查询找到4应该在的位置，即3、5之间，但是**3阶b树的节点最多只能有2个元素**，所以把3、4、5里面的中间元素4上移（中间元素上移是插入操作的关键），上一层节点加入4之后也超载了，继续中间元素上移的操作，现在根节点变成了4、9，还要满足查找树的性质，所以对元素进行调整以满足大小关系，始终维持多路平衡也是b树的优势；
- 插入：中间元素上移的操作；
- 删除：删除后满足B树条件；

##### 02：B+ 树

- B+ 树，是 B 树 的一种变体，查询性能更好，m 阶 的 B+ 树的特征：

###### 特性

1. M 阶 B+ 树，叶子结点**最多包含M-1 个元素**，若是超过，则将这个叶子结点**分裂成左右两个叶子结点**，左叶子结点包含前m/2个记录，右结点包含剩下的记录，**将第m/2+1个记录的key进位到父结点中**，进位到父结点的key左孩子指针向左结点，右孩子指针向右结点， 将当前结点的指针指向父结点。
2. **非叶子结点中有n个关键字 （b树是n-1个）就有n个子节点**，这些**关键字不保存数据，只保存索引**，所有数据都保存在叶子节点（b树是每个关键字都保存数据）
3. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且**叶子结点本身依关键字的大小自小而大顺序链接**
4. 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字；
5. 通常在 b+树 上**有两个指针**，一个指向根结点，一个指向关键字最小的叶子结点；
6. ![B+tree](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/B+tree.jpeg)

##### 03：B树、B+树的区别

1. B+树的**更加矮胖，IO次数少**，磁盘读写代价更低；
   - B树 每个节点中不仅存储索引信息，还存储了存其对应的数据，因此B树的高度更高；
2. B+树的数据信息遍历更加方便，**支持范围查询**【双向链表】
   - B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作，而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树；
3. B+树的**查询效率稳定**
   - 任何关键字的查找必须走从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

##### 04：B* 树：

- 是B+树的变体，在B+树的非根和非叶子结点再**增加指向兄弟的指针**；
- ![B*tree](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/05：树/photos/B*tree.png)

