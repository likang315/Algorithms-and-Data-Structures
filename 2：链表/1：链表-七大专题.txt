
单向链表

typedef struct node        //结点结构，类型重命名
{
	int data;
	struct node * next;
}ElemSN;



1：创建链表

 
1>：正向创建单向链表  （尾插）
     输出链表 （遍历）

#include <stdio.h>
#include <stdlib.h>
#define  N 5
typedef struct node        //结点结构，类型重命名
{
	int data;
	struct node * next;
}ElemSN;

ElemSN * creatLink(int a[])                                  //创建链表
{
	ElemSN * h = NULL, *tail=NULL, *p;
	for (int i = 0; i < N; i++)
	{
		p = (ElemSN *)malloc(sizeof(ElemSN));       //结点的单元的分配
		p->data = a[i];
		p->next = NULL;
		if (!h)                   //判断是否为头结点
			h = tail = p;
		else
			tail = tail->next = p;      //中间尾                   （尾插） 
	}
	return h;
}

void printLink(ElemSN * h)                                     //输出链表，遍历
{
	ElemSN * p;
	for (p = h; p; p = p->next)
		printf("%5d", p->data);
}
                                                                                                                                                                                                                                                     

int main(void)
{
	int a[N] = {1,3,4,5,5};
	ElemSN * head = NULL;
	head=creatLink(a);
	printLink(head);
	return 0;
}





2>:用栈创建链表

#include <stdio.h>
#include <stdlib.h>
typedef struct node        //结点结构，类型重命名
{
	int data;
	struct node * next;
}ElemSN;

ElemSN * creatLink(int a[], int n)     //用栈创建链表
{
	ElemSN **s;
	ElemSN * h;
	int top = -1;
	s = (ElemSN **)malloc((n + 1) * sizeof(ElemSN *));        //存储结点的栈
	for (int i = 0; i < n; i++)
	{
		h = (ElemSN *)malloc(sizeof(ElemSN));             //创建结点链表
		h->data = a[i];
		s[++top] = h;
	}
	s[++top] = NULL;
	while (top != 0)
	{
		top--;
		s[top]->next = s[top + 1];                         //挂链
	}
	return s[top];

}


//递归倒叙输出
void printLink(ElemSN * h)
{
	if(h){
		printLink(h->next);
		printf("%5d",h->data);
	     }
}


int main(void)
{
	int n = 9;
	int a[9] = { 1,2,3,4,5,6,7,8,9 };
	ElemSN * head;
	head=Creatlink(a, n);
	Printlink(head);

	return 0;

}



2：链表的遍历

    输出链表结点数据的最大值



void maxPrintLink(ElemSN * h)
{
	pmax = h;                                     //假设第一个为最大值，然后比较遇大则换
	for(p=h->next;p;p=p->next)
	if (pmax->data < p->data)
	    pmax = p;
	printf("%d", pmax->data);

}

int main(void)
{
	int a[N] = {1,3,4,8,5};
	ElemSN * head = NULL ,* pmax,*p;
	head=creatlink(a);
	maxPrintLink(head);
	return 0;
}





链表的倒叙输出 

1>：递归   

void printLink(ElemSN * h)
{
	if (h) {
		printlink(h->next);
		printf("%5d", h - < data);
	       }
	     
}

2>：非递归用栈输出

void printLink(ElemSN * h)            //倒序输出链表
{
	int * s;                      //指向栈的指针
	int top = -1;
	ElemSN * p;
	s = (int *)malloc(100 * sizeof(int));    //创建栈
	for (p = h; p; p = p->next)
		s[++top] = p->data;                     //把链表的数据一一赋给栈
	while (top != -1)
	{
		printf("%d", s[top--]);                  //输出栈
	}
	return 0;
}


3>：单向链表的遍历，链表倒叙输出，设岗哨

void endPrintLink(ElemSN * h)
{
	ElemSN * pend = NULL, * p;                       //定义一个尾指针岗哨

	while (pend - h)
	{
		for (p = h; p->next - pend; p = p->next);
		printf("%d", p->data);
		pend = p;
	}

}


4>：头插，适用于带表头的单向链表倒叙输出




3：链表查找

ElemSN * findKeyNode(ElemSN * h, int key)
{
	ElemSN * p;
	for (p = h; p && p->data - key; p = p->next);    //先看链表是否跑完，再判断是否要找节点
	if(p)
	{
		return p;
	}
	return NULL;
}



4：链表的删除 （两指针联动）


1>：只删除一个key，找到就跳出

ElemSN * delSingleNode(ElemSN * h, int key)
{
	ElemSN * p, *q=NULL;
	for (p = h; p&&p->data - key; q = p, p = p->next);            //key的查找，空循环
	if (!p)
		printf("not found !\n");
	else
	{
		if (p - h)                              //判断是否为头结点
			q->next = p->next;
		else
			h = h->next;
		free(p);
		p = NULL;
	}
	return h;
}


int main(void)
{
	int a[N] = {1,3,4,8,5};
	int key;
	ElemSN * head = NULL ,*p;
	head=creatLink(a);
	printf("please input key: ");
	scanf("%d", &key);
	head=delSingleNode(head, key);
	printLink(head);
	return 0;
}


2>：删除结点中值重复的结点   （两层循环的嵌套）

void delSameNode(ElemSN * h)
{
	ElemSN * p, *q, *pkey;
	pkey = h;
	while (pkey)            		//外层循环控制所有pkey
	{
		for(q=pkey,p=pkey->next; p ;q=p,p=p->next)		 //内层循环控制有无重复值
		{  
			if(!(p->data-pkey->data))
			{
				q->next=p->next;
				free(p);
				p=q;
			}
		}
		pkey = pkey->next;
	}
}



int main(void)
{
	int a[N] = {1,3,4,3,5};
	int key;
	ElemSN * head = NULL ,*p;
	head=creatlink(a);
	delSameNode(head);
	printlink(head);
	return 0;
}





5：链表插入  （两指针联动）

1>：头插法

将所有奇数结点放在偶数结点之前   

ElemSN * preLink(ElemSN * h)
{
	ElemSN * p, *q;
	q = h;
	p = h->next;
	while (p)                                     //不用判断是否为头结点还是中间尾，永远是以一个链表头插
	{
		if (p->data % 2)
		{
			q->next = p->next;
			p->next = h;                //挂头链挪头指针
			h = p;
			p = q->next;
		}
		else
		{
			q = p;
			p = p->next;
		}
	}
	return h;
}



int main(void)
{
	int a[N] = {1,3,4,3,4,5};
	int key;
	ElemSN * head = NULL ,*p;
	head=creatLink(a);
	head=preLink(head);
	printlink(head);
	return 0;
}


  
2>：尾插法

把链表的值按升序排序(选择排序) 

ElemSN * selectSort(ElemSN * h)
{
	ElemSN * h1, *p, *q, *pmin, *qmin=NULL,*t=NULL;
	h1 = NULL;
	while (h)                                                    //控制外层循环，使所有的结点都拍完
	{
		for(pmin=q=h,p=h->next; p ;q=p,p=p->next)               //找出此链表的最小值
			if (p->data < pmin->data)  
			{
				pmin = p;
				qmin = q;
			}
		if(pmin - h)                                    //判断最小值结点是否为首结点		
			 qmin->next = pmin->next;
		else
			 h = h->next;

		pmin->next = NULL;
		if (!h1)                                        //判断新建得此结点是否为首结点，所以要赋空
			h1 = t = pmin;
		else
			t=t->next = pmin;                      //挂尾链挪尾指针 
	}
	return h1;
	
}



int main(void)
{
	int a[N] = {9,7,4,3,4,5};
	int key;
	ElemSN * head = NULL ,*p;
	head=creatlink(a);
	head=selectsort(head);
	printlink(head);
	return 0;
}




6：带表头结点单向链表

   创建，输出，查找，删除，插入   （操作的是下一个结点，所以插入和删除无需两指针联动）

ElemSN * creakLink(int a[], int n)
{
	ElemSN * p, *h;
	h=p=(ElemSN *)malloc(sizeof(ElemSN));
	h->next= NULL;                                 //头结点只能让其指针域附NULL，数据域为随机值
	for (int i = 0; i < n; i++)
	{
		p = p->next = (ElemSN * )malloc(sizeof(ElemSN));
		p->data = a[i];
		p->next = NULL;
		
	}
	return h;
}

void printLink(ElemSN *h)
{
	ElemSN * p;
	for (p = h; p->next; p = p->next)
		printf("%d", p->next->data);
}

void delKeyNode(ElemSN *h, int key)
{
	ElemSN *p, *pdel;
	for (p = h; p->next&&p->next->data - key; p = p->next);           //查找和删除（无重复值）
		if (!p->next)
			printf("not found!");
		else
		{
			pdel = p->next;
			p->next = pdel->next;
			free(pdel);
		}
}

void  backPrintLink(ElemSN *head)
{
	ElemSN * p,* r;
	r=head->next;
	head->next=NULL;
	while(r)
	{
		p=r;
		r=r->next;
		p->next=head->next;         //挂头链挪头指针
		head->next=p;
	}
}


int main(void)
{
	int a[N] = {9,7,4,3,4,5};
	int key;
	ElemSN * head = NULL ,*p;
	head = creakLink(a, N);
	printf("please input key:");
	scanf("%d", &key);
	delKeyNode( head, key);
	backPrintLink(head);
	printLink(head);
	return 0;
}




7：单向循环链表   （设尾指针更加高效）


1>：创建，输出和删除，插入（和单向循环链表一样）

#include <stdio.h>
#include <stdlib.h>
# define  N   6
typedef struct node        //结点结构，类型重命名
{
	int data;
	struct node * next;
}ElemSN;

1>：建一个挂一个
ElemSN * creatLink(int a[], int n)
{
	ElemSN * h= NULL, *p, *t=NULL;
	for (int i = 0; i < n; i++)
	{
		p=(ElemSN *)malloc(sizeof(ElemSN));
		p->data = a[i];
		if (!h)
		{
			p->next = p;                    //创建的循环链表的头结点指头
			h = t = p;
		}
		else
		{
			p->next = h;
			t =t->next = p;
		}
	
	}
	return h;
}


2>：正向建链，然后让尾节点指向头节点


void * printLink(ElemSN *h)
{
	ElemSN * p=NULL;
	p = h;
	do{
		printf("%d", p->data);
		p = p->next;
	} while (p != h);                               //先执行一次循环
}

ElemSN * delKeyNode(ElemSN *h, int key)
{
	ElemSN *p, *q;
	p = h; q = NULL;
	do {
		if (p->data - key)
		{
			q = p;
			p = p->next;                  //两指针联动，先执行一次循环
		}
		else
			break;
	} while (p - h);
	if (p == h && q)
		printf("Not found!");                          //通过判断q（后继结点)是不是在为不为空，来判断是走了一圈还是删除头结点
	else
	{
		if (p == h)
		{
			for (q = h; q->next - h; q = q->next);         //删头结点时在尾指针上加前驱
			h = h->next;
		}
		q->next = p->next;
		p->next=NULL;
		free(p);
	}

	return h;
}




int main(void)
{
	int a[N]= {1,3,5,7,8,9};
	int key;
	ElemSN * head= NULL, *p, *h=NULL;
	head=creatLink(a,N);
	printf("please input key:");
	scanf("%d", &key);
	head=delKeyNode(head, key);
	printLink(head);
	return 0;
}


2>：约瑟夫环s找出,并按顺序输出

ElemSN * TosephusRing(ElemSN * t, int s)                //（在单向循环链表传尾指针比头指针更加高效）
{
	ElemSN * h1 = NULL, *t1=NULL,*p;
	while (t - t->next)                             //最后一个结点跳出循环
	{
		for (int i = 0; i < s - 1; i++)
			t = t->next;
		    	p = t->next;
			t->next = p->next;
			p->next = NULL;

			if (!h1)
				h1 = t1= p;
			else
				t1 = t1->next = p;       //挂尾链挪尾指针
	}

	if (!h1)                                    //判断是否只有一个结点
		h1 = t;
	else
		t1->next = t;
		t->next = NULL;
	return h1;

}








