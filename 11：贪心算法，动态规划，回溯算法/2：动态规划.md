## 动态规划

### 1：将原问题分解为子问题

**把原问题分解为若干个子问题，子问题和原问题形式相同，让其规模变小**。子问题都解决，原问题即解决，子问题的解一旦求出就会被保存，所以每个子问题只需求解一次

### 2：确定状态

 **某个状态的值，就是这个状态所对应的子问题的解**，有个状态集合专门存放状态

### 3：确定初始状态（边界状态）的值

最开始的子问题的解

### 4：状态转移方程

在该状态下的值，找出下一次的状态之间的关系(**递推公式**),也被称为**状态转移方程**



### 1：青蛙跳台阶

类似于一课二叉树，倒着执行

![递推公式.jpg](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/11%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.jpg?raw=true)

![状态记录表.jpg](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/11%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E8%AE%B0%E5%BD%95%E8%A1%A8.jpg?raw=true)

```java
//最后一步的只能从倒数第一个台阶或者倒数第二个台阶,F(n)=F(n-1)+F(n-2),时间复杂度：O(n)
public int getClimbingWays(int n)
{
    if(n<1)
        return 0;
    if(n=1)
        return 1;
    if(n=2)
        return 2;
    int a=1,b=2,temp=0;
    for(int i=3;i<=n;i++)
    {
        temp=a + b;
        a=b;
        b=temp;
    }
    return temp;
}
```


