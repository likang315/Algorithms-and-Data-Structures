### 1：旋转数（循环数组）

###### 	给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数

```java
public class Solution {
    public void rotate(int[] nums, int k) {  
        int  n=nums.length;
        k= k % n;
        for(int i=0;i<k;i++)//j循环次数k
        {
            int temp=nums[n-1];
            for(int j=n-1;j>0;j--)
            {
                nums[j]=nums[j-1];
            }
            nums[0]=temp;
        }
	}
}
```

### 2：从排序数组中删除重复项

###### 	在原地修改输入数组并在使用 O(1) 额外空间

```java
public class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0)
            return 0;
        int i=0;
        for(int j=1;j<nums.length;j++)
        {
            if(nums[i]!=nums[j])
            {
                i++;
                nums[i]=nums[j];
            }
        }
        return i+1;
    }
}
```

### 3：给定一个整数数组，判断是否存在重复元素

```java
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length>=2)
        {
            for(int i=0;i<nums.length;i++)
            {
                for(int j=i+1;j<nums.length;j++)
                {
                    if(nums[i]==nums[j])
                      return true;
                }
            }
 	   }
	return false;
	}		
}

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length>0)
        {
            HashMap<Integer,Integer> map=new HashMap();
            map.put(nums[0],1);
              for(int i=1;i<nums.length;i++)
              {

            	if(map.get(nums[i]) != null)
		     	{
           			return true;
     			}else
     			{
              		map.put(nums[i],1);
			    }
			}
	    }
	  return false;
	}
}
```

### 4：数组序列中（存在负数），求子序列和值最大的子序列（分治）

```java
//复杂度为O(n^3)，暴力法，求出所有的子序列
public int maxSum(int[] a)
{
    int max=0, mi, mj;
	for (int i = 0;i < a.length;i++)//两指针联动
	{
		for (int j = i;j < a.length;j++)
		{
			int sum = 0;
			for (int k = i; k <= j; k++)
				sum += a[k];
			if (sum > max)
			{
				max = sum;
				mi = i;
				mj = j;
			}
		}
	}
    return max;
}


//O(n^2+n),新的数组存放当前节点的前面所有节点的和
public int maxSum(int[] a)
{
    int sum,max=0, mi, mj;
    int[] a = new int[a.length]{0};
	for (int i = 1; i <= n; i++)
		s[i] = s[i - 1] + a[i - 1];
    
	for (int i = 1; i <= s.legnth; i++)
	{
		for (int j = i; j <= s.length; j++)
		{
			sum = s[j] - s[i - 1];
			if (sum > max)
			{
				max = sum;
				mi = i - 1;
				mj = j;
			}
		}
	}
    return max;
}


//分治法 O(nlogn)
public int maxSum(int[] a, int left, int right) 
{ 
    int sum = 0, i;
	int leftMaxSum=0,rightMaxSum=0;
	if (left >= right)
		return a[left];
	else 
	{
		int mid = (left + right) / 2;
		leftMaxSum  = maxSum(a, left,mid);
		rightMaxSum = maxSum(a, mid + 1, right);
		//中间部分，从右边开始--
		int m1 = 0,leftSum = 0;
		for (i = mid; i >= left; i--)
		{
			leftSum = leftSum + a[i];
			if (leftSum > m1)
			{
				m1 = leftSum;
				mi = i;
			}
		}
		//中间部分，从左边开始++
		int m2 = 0, rightSum = 0;
		for (i = mid + 1; i <= right; i++)
		{
			rightSum = rightSum + a[i];
			if (rightSum > m2)
			{
				m2 = rightSum;
				mj = i;
			}
		}
		sum = m1 + m2;

		if (sum < leftMaxSum)
			sum = leftMaxSum;
		if (sum < rightMaxSum)
			sum = rightMaxSum;
	}
	return sum;
}
```





