### 回溯算法、试探算法

------

是一种系统地搜索问题的解的方法

##### 步骤：

1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解
2. 确定易于搜索的解空间结构,使得能用[回溯法](https://baike.baidu.com/item/回溯法)方便地搜索整个解空间 
3. 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索

##### 1：马踏棋盘问题

- 有 8 * 8的棋盘，刚开始让马在棋盘的任意一个位置上，让马踏日，（有八个方向），没踏过并且可踏，直到踏完所有的格子（cnt==64）输出，再回溯到上一个格子，一直到所有解输出完毕

```java
public class Main {
  		// 定义 8 * 8 棋盘，默认值为0
  		private int[][] m = new int[8][8];
  		// 定义已踏格子
  	  private int count = 0;
  		// 定义马可以跳的八个方向
    	private int[8][2] move = {
				{ 2,1 },
				{ 1,2 },
				{ -1,2 },
				{ -2,1 },
				{ -2,-1 },
				{ -1,-2 },
				{ 1,-2 },
				{ 2,-1 }
			};
  // 递归踏马
  void horse(int x, int y) {
      int a, b;
      for (int i = 0; i < 8; i++) {
          a = x + move[i][0];
          b = y + move[i][1];
          // 能踏并且没踏过
          if (a >= 0 && a < 8 && b >= 0 && b < 8 && m[a][b] != 0)  {
              m[a][b] = ++count;
              if (cnt < 64)
                	Horse(a, b);
              else
                	print();
              m[a][b] = 0;
              count--;
          }
      }
  }
  public void solution() {
  		m[0][0] = 1;
    	hourse(0, 0);
  }
}
```

##### 2：迷宫问题

