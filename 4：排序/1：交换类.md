### 内部排序：指的是排序内存中进行的过程

### 外部排序：指的是待排序的数量很大，以至于内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的过程

## 交换类：

##### 1：冒泡排序法，时间复杂度O(n^2),最好时：O(n),最坏时O(n^2)

```java
设置flag，如果一次遍历完没有交换，则证明其已是有序序列
void bubbleSort(int a[], int n)
{
	int x,flag;
	for (int i = 0; i< n-1; i++)
	{
	    flag = 0；
	    for (int j = 0; j< n-1-i; j++)
		 if (a[j] > a[j + 1])
		 {
			x = a[j];
			a[j] = a[j + 1];
			a[j + 1] = x;
			flag=1；
		 }
		if(flag==0)
		{
			return;
		}
	}
}      
```



#### 2：鸡尾酒排序(定向冒泡排序)：从低到高然比较，然后从高到低比较

```java
void cocktailSort(int a[], int n)
{
    int left = 0,x;                            // 初始化边界
    int right = n - 1;
    while (left < right) 						//不是二分
    {
        for (int i = left; i < right; i++)   // 前半轮,将最大元素放到后面
        {
            if (a[i] > a[i + 1])
            {
                  x = a[i];
	 			a[i] = a[i + 1];
				a[i + 1] = x;
            }
        }
        right--;

        for (int j = right; j > left; j--)   // 后半轮,将最小元素放到前面
        {
            if (a[j] < a[j - 1] )
        	{
            	 x = a[j];
            	 a[j] = a[j + 1];
    		     a[j + 1] = x;
        	}
        }
       left++;
	}
}
```



#### 3：快速排序法

**时间复杂度：O(nlogn)，稳定性：不稳定**
最优时：每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度：O(nlogn)
最差时：每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，O(n^2）

```java
void quickSort(int a[],int left,int right)
{
　　int i=left;
　　int j=right;
　　int temp=a[left];
　　if(left >= right)						//二分终止条件
　　　　return;

　　while(i<j)
　　{
　　　　while(i<j&&a[j]>=temp) 
　　　　    j--;
　　　　if(j>i)
　　　　　　a[i]=a[j];

　　　　while(i<j&&a[i]<=temp)
　　　　    i++;
　　　　if(i<j)
　　　　　　a[j]=a[i];
　　}
　　a[i]=temp;
　　quickSort(a,left,i-1);
　　quickSort(a,i+1,right);
}
	
quickSort(a, 0,N-1);
```










