
插入类

1：直接插入排序法：时间复杂度：O(n^2),最好时(升序)：O(n),最坏时(降序)：O(n^2),具有稳定性

	void insertionSort(int a[],int n)
	{
		int i=1, j, x;
		while (i - n)
		{
			x = a[i];
			for (j = i - 1; j > -1 && a[j] > x; a[j + 1] = a[j], j--);
			a[j + 1] = x;
			i++; 
		}
	}



2：二分插入排序，当 n 较大时使用，利用二分查找法减少比较的次数，然后后移整个数组，一步插到位
	时间复杂度：O(n^2)，最优时：O(nlogn)，最差O(n^2)，具有稳定性


void InsertionSortDichotomy(int a[], int n)
{
    for (int i = 1; i < n; i++)
    {
        int temp= a[i];                  
        int left = 0;                  
        int right = i - 1;                
        while (left <= right)         
        {
            int mid = (left + right) / 2;
            if ( a[mid] > get )
                right = mid - 1;
            else
                left = mid + 1;
        }

        for (int j = i - 1; j >= left; j--)  
        {
            a[j + 1] = a[j];
        }

        a[left] = temp;                 
    }
}




2：希尔排序法（递减增量排序）：
	利用分二分法，把全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步
	减少比较的次数，然后算法再取越来越小的步长进行排序，最后一次就是直接插入排序
	
       时间复杂度：O(nlogn)-O(n^2)，最优时：O(nlogn)，最差时：O(n^2),根据步长的选取有关,不稳定


void ShellSort(int a[], int n)
{
	int temp;
	for(int gap = n/2; gap > 0; gap/= 2) 		//控制步长,每次步长减少一半，最后递减到1
	{
		for(int i = gap; i < n; i++)		//跑完所有元素
		{
			temp = a[i];
			int  j;
			for(j = i; j >= gap && a[j-gap] > temp; j -= gap)	//按步长往下比较，直到小于步长
				a[j] = a[j - gap];
			a[j] = temp;
		}
	}

}




