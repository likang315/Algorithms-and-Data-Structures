## 归并排序：

###### 时间复杂度：O(nlogn)，最优时：O(nlogn)，最差时：O(nlogn)，稳定

　　递归实现的归并排序是**采用分治方法**，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题，**先分后治**

**并排序分成有序数组后，合并两个有序数组**

###### 递归：从上到下

编写：

###### ​1：先写合并void Merge(int[] a, int left, int mid, int right)  

​	1：分别存在两个数组

​	2：比较大小，合并

​	3：多余元素放入

###### 	2：void MergeSort(int[] a, int left, int right)

```java
// 合并两个已排好序的数组a[left...mid] 和 a[mid+1...right]
void Merge(int[] a, int left, int mid, int right)  
{    
    int i,j,
    int n1= mid-left+1;
    int n2= right - mid;
    int L[n1],R[n2];                     
    for( i = 0 ; i<n1 ; i++)
	L[i] = a[left+i];
    for( j = 0 ; j<n2 ; j++)
	R[j] = a[mid+1+j];				//初始化两个子数组

    i=j=0;			//合并两个有序数组
    k=left;
    while (i < n1 && j < n2 )
    {
       if(L[i] <= R[j])     		//稳定性
      		a[k++] = L[i++];
       else
      		a[k++] = R[j++];
    }
    while (i < n1)
       a[k++] = L[i++];
    while (j < n2)
       a[k++] = R[j++];
}

void MergeSort(int[] a, int left, int right)
{
    if (left < right)    //当待排序的序列长度为1时，递归开始回溯，进行merge操作
    {
        int mid = (left + right) / 2;
        MergeSort(a, left, mid);		
        MergeSort(a, mid + 1, right);
        Merge(a, left, mid, right);
    }
}
```

##### 非递归：从下到上，先治后分

将待排序的数列分成**若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并**；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止




