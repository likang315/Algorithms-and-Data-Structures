## 选择类：

### 1：简单选择排序法，时间复杂度O(n^2),最好时：O(n^2),最坏时：O(n^2),不稳定

```java
void selectSort(int[] a, int n)
{
	int i, j, t, min;
	for (i = 0; i<n - 1; i++)              //最后一个不用比
	{
		min = i;
		for (j = i + 1; j<n; j++)
		{
			if (a[j]<a[min])
			    min = j;
		}
		if (i != min)
		{
			t = a[i];
			a[i] = a[min];
			a[min] = t;
		}
	}
}
```



### 2：堆排序(heapSort)，时间复杂度：O(nlogn)，最优时：O(nlogn)，最差时：O(nlogn)，稳定性：不稳定

###### 1：列举四个函数，依次完善

###### ​	void Swap(int a[], int i, int j)

######        void heapify(int a[], int i, int size) 

###### ​        void buildHeap(int a[], int n)  

######         void heapSort (int a[], int n)  



```java
void Swap(int a[], int i, int j)
{
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

void heapify(int a[], int i, int size)    // 从A[i]向下,调整堆
{
    int left= 2 * i + 1;        
    int right = 2 * i + 2;        
    int max = i;
                     
    if (left < size && a[left] > a[max])
        max = left;
    if (right < size && a[right] > a[max]) 
        max = right;

    if (max != i)
    {
        Swap(a, i, max);              
        Heapify(a, max, size);         // 递归调用，继续从当前结点向下进行堆调整，max为当前交换的结点
    }	
}

void buildHeap(int a[], int n)            // 建最大堆，时间复杂度O(nlogn)
{
   for (int i = n / 2 - 1; i >= 0; i--)  //从非叶子结点开始向上进行堆调整,因为叶子结点总比双分支结点多1
        Heapify(a, i, n);
}

void heapSort(int a[], int n)
{
    BuildHeap(a, n);
    while (n> 1)    　　　　　　 // 堆（无序区）元素个数大于1，未完成排序
    {
        Swap(a, 0, --n);	// 不稳定
        Heapify(a, 0, n);       // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)
    }
}
```





###### 3：堆排序，传过来的参数是完全二叉树

```c
void heapSort(BTNode * root) {
	BTNode **Q;
	BTNode *p,*pmin, *t;
	int front, rear,exchange;

//1:声明队列
Q = (BTNode **)malloc((N + 1)*sizeof(BTNode *));
front = rear = 0;

//2:将完全二叉树存入队列
Q[++rear] = root;
while (1){
	p = Q[++front];
	if (!(p->left) && !(p->right))
		break;
	else {
		if (p->left)
			Q[++rear] = p->left;
		if (p->right)
			Q[++rear] = p->right;
	}
}

//3:调整小顶堆,每次从下往上调
while(front-1){
	while(1){
		int tag = 1;
		for (int i = front - 1; i > 0; i--) {
			p = Q[i];
			pmin = p;
			if (pmin->data>p->left->data)
				pmin = p->left;
			if (pmin->data> p->right->data)
				pmin = p->right;
			if (p - pmin) {
				t = pmin;
				pmin = p;
				p = t;
				tag=0;		
			}
		}
		if(tag)
		   break;
	     }

​	//4:根节点的值和最后一个节点的值交换，然后砍掉
​	exchange = Q[rear]->data;
​	Q[rear--]t->data = root->data;
​	root->data = exchange;
​	if (Q[front - 1]->right)
​		Q[front - 1]->right = NULL;
​	else {
​		Q[front - 1]->left = NULL;
​		front--;
​	}

} 
//5：输出队列，此时rear，front都在第一个结点处，为降序
for (int i = 0; i < N; i++)
	printf("%5d", Q[rear++]->data);

}
```






