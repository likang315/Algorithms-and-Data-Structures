## 选择类：

### 1：简单选择排序法，时间复杂度O(n^2),最好时：O(n^2),最坏时：O(n^2),不稳定

```java
void selectSort(int[] a)
{
	int i, j, t, min;
	for (i = 0; i< a.length - 1; i++)              //最后一个不用比
	{
		min = i;
		for (j = i + 1; j < a.length; j++)
		{
			if (a[j]<a[min])
			    min = j;
		}
		if (i != min)
		{
			t = a[i];
			a[i] = a[min];
			a[min] = t;
		}
	}
}
```



### 2：堆排序(heapSort)，时间复杂度：O(nlogn)，最优时：O(nlogn)，最差时：O(nlogn)，稳定性：不稳定

###### 1：列举四个函数，依次完善

###### void Swap(int a[], int i, int j)

######        void heapify(int a[], int i, int size) 

###### void buildHeap(int a[], int n)  

######         void heapSort (int a[], int n)  



```java
void Swap(int[] a, int i, int j)
{
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

void heapify(int a[], int i)    // 从A[i]向下,调整堆
{
    int left= 2 * i + 1;        
    int right = 2 * i + 2;        
    int max = i;
                     
    if (left < a.length && a[left] > a[max])
        max = left;
    if (right < a.length && a[right] > a[max]) 
        max = right;

    if (max != i)
    {
        Swap(a, i, max);              
        Heapify(a, max);         // 递归调用，继续从当前结点向下进行堆调整，max为当前交换的结点
    }	
}

void buildHeap(int a[])            // 建最大堆，时间复杂度O(nlogn)
{
   for (int i = a.length / 2 - 1; i >= 0; i--)  //从非叶子结点开始向上调整,叶子结点总比双分支结点多1
        Heapify(a, i);
}

void heapSort(int a[])
{
    int n = a.length;
    BuildHeap(a);
    while (n> 1)    　　　　　　 // 堆（无序区）元素个数大于1，未完成排序
    {
        Swap(a, 0, --n);	// 不稳定
        Heapify(a, 0, n);       // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)
    }
}
```










