## 插入类

#### 1：直接插入排序法：

###### 时间复杂度：O(n^2),最好时(升序)：O(n),最坏时(降序)：O(n^2),具有稳定性

```java
void insertSort(int[] a)
{
	int i=1, j, x;
	for(int i=1;i < a.length;i++)
	{
         x = a[i];
		for (j = i - 1; j > -1 && a[j] > x; a[j + 1] = a[j], j--);
		a[j + 1] = x;
	}
}
```



#### 2：二分插入排序

当 n 较大时使用，利用二分查找法减少比较的次数，把有序区间用二分查找找到待插入元素的最终位置然后移动整个数组，一步插到位，每次都减少一半的比较

###### 时间复杂度：O(n^2)，最优时：O(nlogn)，最差O(n^2)，具有稳定性

```java
void InsertionSortDichotomy(int[] a)
{
    for (int i = 1; i < a.length; i++)
    {
        int temp= a[i];                  
        int left = 0;                  
        int right = i - 1;               
        while (left <= right)         
        {
            int mid = (left + right) / 2;
            if ( a[mid] > temp )
                right = mid - 1;
            else
                left = mid + 1;
        }

        for (int j = i - 1; j >= left; j--)
        {
            a[j + 1] = a[j];
        }
        a[left] = temp;
	}
}
```



#### 2：希尔排序法（递减增量排序，相对有序）：

​	利用二分法，把全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步减少比较的次数，然后算法再取越来越小的步长进行排序，最后一次就是直接插入排序，大家都相邻
​	

**时间复杂度：O(nlogn)-O(n^2)，最优时：O(nlogn)，最差时：O(n^2),根据步长的选取有关,不稳定**

######     编写：三个循环

```java
void ShellSort(int[] a)
{
	int temp;
	for(int gap = a.length/2 ; gap > 0 ; gap/= 2) 		//控制步长,每次步长减少一半，最后递减到1
	{
		for(int i = gap; i < a.length; i++)		  	    //跑完所有元素
		{
			temp = a[i];
			int  j;
			for(j = i; j >= gap && a[j-gap] > temp; j -= gap)	//大于等于步长，因为第二次开始往后比
				a[j] = a[j - gap];
			a[j] = temp;
		}
	}
}
```


