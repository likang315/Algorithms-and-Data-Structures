
  堆（heap）排序

#include<stdio.h>
#include<stdlib.h>  //malloc ,free 函数
#define N 100

//声明结点
typedef struct node {
	int data;
	struct node *left;
	struct node *right;
}BTNode;

//创建完全二叉树      
BTNode * creatCompleteBTNOde(int a[],int n) {
	BTNode *root, *p, *pa;
	BTNode **Q;
	int front, rear;
	//存放除根节点外的其余节点，创建队列
	Q = (BTNode **)malloc(sizeof(BTNode *));
	front = rear = 0;

	//创建根节点
	pa = root = (BTNode *)malloc(sizeof(BTNode));

	for (int i = 1; i < n; i++) 	{
		p = (BTNode *)malloc(sizeof(BTNode));
		p->data = a[i];
		p->left = p->right = NULL;
		Q[++rear] = p;
		if (!pa->left)
			pa->left = p;
		else {
			pa->right = p;
			pa = Q[++front];
		}
	}
	free(Q);
	return root;
}



//堆排序
void heapSort(BTNode * root) {
	BTNode **Q;
	BTNode *p,*pmin, *t;
	int front, rear, end,exchange;

	//1:声明队列
	Q = (BTNode **)malloc((N + 1)*sizeof(BTNode *));
	front = rear = 0;

	//2:将完全二叉树存入队列
	Q[++rear] = root;
	while (1){
		p = Q[++front];
		if (!(p->left) && !(p->right))
			break;
		else {
			if (p->left)
				Q[++rear] = p->left;
			if (p->right)
				Q[++rear] = p->right;
			end = rear;
		}
	}

	//3:调整小顶堆
	while(front-1){
		while (1) {
			int tag = 1;
			for (int i = front - 1; i > 0; i--) {
				p = Q[i];
				pmin = p;
				if (pmin->data>p->left->data)
					pmin = p->left;
				if (pmin->data> p->right->data)
					pmin = p->right;
				if (p - pmin) {
					t = pmin;
					pmin = p;
					p = t;
					tag = 0;
				}
			}
			if (tag)
				break;
		}

		//4:根节点的值和最后一个节点的值交换，然后砍掉
		exchange = Q[rear]->data;
		Q[rear--]t->data = root->data;
		root->data = exchange;
		if (Q[front - 1]->right)
			Q[front - 1]->right = NULL;
		else {
			Q[front - 1]->left = NULL;
			front--;
		}

	} 
	//5：输出队列，此时rear，front都在第一个结点处，为降序
	for (int i = 0; i < N; i++)
		printf("%5d", Q[rear++]->data);

}





int main() {
	int a[11] = { 3,2,13,8,12,7,9,1,6,11,4 };
	BTNode *root;
	root=creatCompleteBTNOde(a, 11);
	heapSort(root);
	return 0;

}






