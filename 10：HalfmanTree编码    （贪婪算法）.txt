

1：//链式创建HalfmanTree树，一般未知创建几个结点（装箱问题）

#include<stdio.h>
#include<stdlib.h>
//halfman树结点类型
typedef struct node {
	char word;
	int weight;
	struct node *left, *right;
}HalfNode;

//创建森林,存放叶子结点
HalfNode ** creatForest(int n) 
{
	HalfNode **F;
	F = (HalfNode **)malloc(n * sizeof(HalfNode *));
	for (int i = 0; i < n; i++) 
	{
		char ch;
		int w;
		F[i] = (HalfNode *)malloc(sizeof(HalfNode));
		F[i]->left = F[i]->right = NULL;
		printf("请输入第%d个数据：",i+1);
		scanf("%c",&ch);
		scanf("%d", &w);
		F[i]->word = ch;
		F[i]->weight = w;
	}
	return F;
}

//创建HalfMan树
HalfNode * creatHalfTree(HalfNode **F,int n) 
{
	int k1, k2;
	HalfNode *p;
	for (int loop = 1; loop < n; loop++)
	{
		for (k1 = 0; k1 < n && !F[k1]; k1++);
		for (k2 = k1 + 1; k2 < n && !F[k2]; k2++);
		for (int i = k2; i < n; i++)
		{
			if (F[i]) 
			{
				if (F[i]->weight < F[k1]->weight) 
				{
					k2 = k1;
					k1 = i;
				}
				else
					if (F[i]->weight < F[k2]->weight)
						k2 = i;
			}
			
		}
		p = (HalfNode *)malloc(sizeof(HalfNode));//创建双亲
		p->word = 'X';
		p->weight = F[k1]->weight + F[k2]->weight;
		p->left = F[k1];
		p->right = F[k2];
		F[k1] = p;
		F[k2] = NULL;
	}
	return F[k1];
}

int main(void) {
	HalfNode *root;
	HalfNode **F;
	int n;
	printf("Please input leaves'nubmber:");
	scanf("%d", &n);

	//创建森林
	F= creatForest(n);

	//创建HalfMan树
	root = creatHalfTree(F, n);

	//输出HalfMan树，调用遍历二叉树的前，中，后序遍历


}















2：//数组创建HalfmanTree树，因为已知叶子结点个数，知道创建几个空间

#include<stdio.h>
#include<stdlib.h>
typedef struct 
{
	char word;
	int weight;
	int left, right, parent;
	int * code;
}HalfNode;
  
//创建森林
void creatForest(HalfNode *F,int n)
{
	char ch;
	int w;
	for (int i = 0; i < n; i++)
	{
		printf("请输入ch 和 w 的值：");
		scanf("%c", &ch);
		scanf("%d", &w);
		F[i].weight = w;
		F[i].left = F[i].right = F[i].parent = -1;
	}
	
}

//创建HalfmanTree
void  creatHalfmanTree(HalfNode *F, int n)
{
	int loop, k1, k2,i;
	for (loop = 0; loop < n - 1; loop++)
	{
		for (k1 = 0; k1 < n + loop && F[k1].parent != -1; k1++);
		for (k2 = k1 + 1; k2 < n + loop && F[k2].parent != -1; k2++);
		for (i = k2; i < n + loop; i++)
		{
			if (F[i].parent== -1)
			{
				if (F[i].weight < F[k1].weight)
				{
					k2 = k1;
					k1 = i;
				}
				else
					if (F[i].weight < F[k2].weight)
						k2 = i;
			}
		}
		F[i].word = 'X';
		F[i].weight = F[k1].weight + F[i].weight;
		F[i].left = k1;
		F[i].right = k2;
		F[i].parent = -1;
		F[k1].parent = F[k2].parent = i;
	}
}


//创建 HalfmanCode
void HalfmanCode(HalfNode *F, int n)
{
	int c, pa, i;
	int *p;
	for (i = 0; i < n; i++)
	{
		F[i].code = p=(int *)malloc(n * sizeof(int));
		p[0] = 0;
		c = i;
		while (F[c].parent!=-1)
		{
			pa = F[c].parent;
			if (F[pa].left == c)
				p[++p[0]] = 0;
			else
				p[++p[0]] = 1;
			c = pa;
		}
	}
}

//输出
void printHalfmanCode(HalfNode *F, int n)
{
	for (int i = 0; i < n; i++)
	{
		int * p = F[i].code;
		printf("%c的编码是：", F[i].word);
		for (int j = 1; i <= n; j++)
			printf("%d", p[j]);    
		printf("\n");
	}
}

int main(void)
{
	HalfNode *F;
	int  n;
	printf("请输入叶子的个数：");
	scanf("%d", &n);
	F = (HalfNode *)malloc((2 * n - 1) * sizeof(HalfNode));
	//创建森林
	creatForest(F,n);
	//创建HalfmanTree
	creatHalfmanTree(F,n);
	//创建 HalfmanCode
	HalfmanCode(F,n);
	//输出
	printHalfmanCode(F,n);
}









