### 1：反转字符串

###### 原地修改输入数组、使用 O(1) 的额外空间

```
//前后交换，O(1)空间
public void reverseString(char[] s)
{
    if(s.length>1)
    {  
        for(int i=1;i<s.length/2+1;i++)
        {
            char x=s[s.length-i];
            s[s.length-i]=s[i-1];
            s[i-1]=x;
        }
    }
}
```

### 2：整数反转

###### 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转，可以用栈

```
// % 10 就是去最后一位，每次除10 相当于少一位
public int reverse(int x)
{
    int rev = 0;
    while (x != 0) {
        int pop = x % 10;
        x /= 10;

        if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) 
            return 0;
        if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8))
            return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}
```

### 3：求一个字符串的所有子字符串（暴力）

```
public  void allchildString(String s)
{
    for(int i=0;i<s.length();i++)
    {
        for(int j=i;j<s.length();j++)
        {
            System.out.print(s.substring(i,j+1)+"  ");
        }
        System.out.println();
    }
}
```

### 4：最长无重复子串

```
//滑动窗口
public int lengthOfLongestSubstring(String s) {
    int length=s.length();
    HashSet<Character> set = new HashSet<Character>();
    //一个控制头，一个控制尾（窗口）
    int re=0,i=0,j=0;
    while(j < length)
    {
        if(!set.contains(s.charAt(j)))
        {
            set.add(s.charAt(j++));
            re=Math.max(re,j-i);    //和之前的最长的比较谁大
        }else
        {
            set.remove(s.charAt(i++));  //知道重复出除去
        }
    }
    return re;
}
```

### 5：最长回文子串，时间复杂度：O(n^2)，空间复杂度：O(1)

```
//中心扩展算法：以每个字母为回文中心,考虑回文长度为奇数和偶数的情况
class Solution {
    public String longestPalindrome(String s) {
        if(s == null && s.length()<=0)
            return "";
        int start =0 ,end = 0;
        for(int i=0;i<s.length();i++)
        {
            int len1=expandCenter(s,i,i); //aba
            int len2=expandCenter(s,i,i+1); //abba
            int len=Math.max(len1,len2);
            if(len > end-start)
            {
                start=i - (len-1)/2;
                end=i + len/2;
            }
        }
        return s.substring(start,end+1);
    }
    
    //判断是不是回文串
    public int expandCenter(String s,int left,int right)
    {
        while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right))
        {
            left--;
            right++;
        }
        return right-left-1; //两边扩充一对，右边没有除去
    }
}
```

### 6：最长公共子串（dp算法）：

###### 字符子串：字符串中连续的n个字符

[![最长公共子串.jpg](https://github.com/likang315/Algorithms-and-Data-Structures/raw/master/5%EF%BC%9A%E4%B8%B2/String/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.jpg?raw=true)](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/5：串/String/最长公共子串.jpg?raw=true)

```
//按行走,int[]默认值为：0
public int getcommenstrLength(String s1, String s2)
{
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int[][] dp = new int[c1.length+1][c2.length+1];
        int max = -1;
        for(int i = 1; i< c1.length+1; i++)
        {
            for(int j = 1; j < c2.length+1; j++)
            {
                if (c1[i-1] == c2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1]+1;
                    if(dp[i][j]> max )
                    {
                        max = dp[i][j];
                    } 
                }
            }
        }
        return max;
    }
}
```

### 7：最长公共子序列

###### 字符子序列：字符串中不一定连续但先后顺序一致的n个字符

[![LCS.png](https://github.com/likang315/Algorithms-and-Data-Structures/raw/master/5%EF%BC%9A%E4%B8%B2/String/LCS.png?raw=true)](https://github.com/likang315/Algorithms-and-Data-Structures/blob/master/5：串/String/LCS.png?raw=true)

```
public  int LCS (String s1, String s2)
{
    int[][] dp = new int[s1.length() + 1][s2.length()+ 1];
    for (int i = 1;i <= s1.length(); i++)
    {
        for (int j = 1;j <= s2.length(); j++)
        {
            if (s1.charAt(i - 1) == s2.charAt(j - 1))
            {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else
            {
                //上面和左面的谁大赋谁
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[s1.length()][s2.length()];
}
```

### 8：String 1 变为 String 2 的 最小操作数

```
public static int minExchange(String word1,String word2)
{
    int row = word1.length();
    int col = word2.length();
    int[][] dp = new int[row+1][col+1];
    for(int i=1;i <= row;i++)
    {
        for(int j=1;j <= col;j++)
        {
            if(word1.charAt(i-1) == word2.charAt(j-1))
            {
                dp[i][j] = dp[i-1][j-1]+1;
            }
            else
            {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    //s1 + s2 的总长度 减去 s1和s2 共同的最大公共子序列
    return row + col - 2 * dp[row][col];
}
```

### 9：