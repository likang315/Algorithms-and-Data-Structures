### 1：反转字符串

###### 	原地修改输入数组、使用 O(1) 的额外空间

```java
class Solution {
    public void reverseString(char[] s) {
        if(s.length>1)
        {  
           for(int i=1;i<s.length/2+1;i++)
           {
              char x=s[s.length-i];
               s[s.length-i]=s[i-1];
               s[i-1]=x;
           }
        }
    }
}
```

### 2：整数反转

###### 	给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转，用栈

```java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;

       		if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) 
          		return 0;
         	if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8))
           		return 0;
            rev = rev * 10 + pop;
        }
	    return rev;
	}
}
```

### 3：最长无重复子串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int length=s.length();
        HashSet<Character> set = new HashSet<Character>();
        int re=0,i=0,j=0;
        while(i<length && j< length)
        {
             if(!set.contains(s.charAt(j)))
             {
                 set.add(s.charAt(j++));
                 re=Math.max(re,j-i);    //和之前的最长的比较谁大
             }else
             {
                 set.remove(s.charAt(i++));  //知道重复出除去
             }
        }
        return re;
    }
}
```

### 4：最长回文子串，时间复杂度：O(n^2)，空间复杂度：O(1)

```java
//2n?1中心：在于所含字母数为偶数的回文的中心可以处于两字母之间
class Solution {
    public String longestPalindrome(String s) {
        if(s == null && s.length()<=0)
            return "";
        int start =0 ,end = 0;
        for(int i=0;i<s.length();i++)
        {
            int len1=expandCenter(s,i,i); //aba
            int len2=expandCenter(s,i,i+1); //abba
            int len=Math.max(len1,len2);
            if(len > end-start)
            {
                start=i - (len-1)/2;    //4,5,6,7
                end=i + len/2;
            }
        }
        return s.substring(start-1,end);
    }
    
    int expandCenter(String s,int left,int right)
    {
        while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right))
        {
            left--;
            right++;
        }
        return right-left-1; //两边扩充一对，右边没有除去
    }
}
```

### 5：最长公共子串长度(二维数组)

```java
public  String getcommenstrLength(String s1, String s2){
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int[][] dp = new int[c1.length+1][c2.length+1];
        int max = 0;
        int num=0;
        StringBuffer sb=new StringBuffer();
        //第一步，得到动态序列（二维数组--对角线）
        for(int i = 1; i< c1.length+1; i++)
        {
            for(int j = 1; j< c2.length+1; j++)
            {
                if (c1[i-1] == c2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1]+1;   //值为子串长度
                }
            }
        }
       //根据dp定位字符串位置
        if(c1.length < c2.length)
            for(int i = 0;i<c1.length;i++)
                for(int j = 0;j<c2.length;j++)
                {
                    if(dp[i][j] > max)
                    {
                        max = dp[i][j];
                        num = i;
                    }
                }
        else {
                for(int i = 0;i<c2.length;i++)
                    for(int j = 0;j<c1.length;j++)
                    {
                        if(dp[j][i] > max)
                        {
                            max = dp[j][i];
                            num = j;
                        }
                    }
            }
        for(int i=num-max;i<=num;i++)
        {
            sb.append(c1[i]); 
        }
       return sb.toString();
    }
```

### 6：最长公共子序列：

```java
//最长公共子串要求在原字符串中是连续的，而子序列只需要保持相对顺序一致，并不要求连续
public int getcommenstrLength(String s1, String s2){
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int[][] dp = new int[c1.length+1][c2.length+1];
        int max = -1;
        for(int i = 1; i< c1.length+1; i++)
        {
            for(int j = 1; j< c2.length+1; j++)
            {
                if (c1[i-1] == c2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1]+1;
                    if(dp[i][j]> max )
                        max = dp[i][j];
                }
            }
        }
        return max;
    }
}
```

### 7：













